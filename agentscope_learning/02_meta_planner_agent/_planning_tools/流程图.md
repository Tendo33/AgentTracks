åŸºäºä»£ç æ·±åº¦åˆ†æï¼Œæˆ‘ä¸ºä½ æä¾›ä¸€ä¸ª**è¶…è¯¦ç»†çš„MetaPlannerå·¥ä½œæµç¨‹**ï¼ŒåŒ…å«æ¯ä¸ªæ–¹æ³•è°ƒç”¨ã€å‚æ•°ä¼ é€’å’Œæ•°æ®æµè½¬ï¼š

## ğŸš€ å®Œæ•´æ‰§è¡Œæµç¨‹è¯¦è§£

### **é˜¶æ®µ1ï¼šç³»ç»Ÿåˆå§‹åŒ–**

#### **1.1 MetaPlannerå¯¹è±¡åˆ›å»º**
```python
# åœ¨ main.py ä¸­è°ƒç”¨
agent = MetaPlanner(
    name="Task-Meta-Planner",
    model=AnthropicChatModel(
        api_key=os.environ.get("ANTHROPIC_API_KEY"),
        model_name="claude-sonnet-4-20250514",
        stream=True,
    ),
    formatter=AnthropicChatFormatter(),
    toolkit=planner_toolkit,          # è§„åˆ’å™¨å·¥å…·åŒ…
    worker_full_toolkit=worker_toolkit, # Workerå®Œæ•´å·¥å…·åŒ…
    agent_working_dir=agent_working_dir,
    memory=InMemoryMemory(),
    state_saving_dir=f"./agent-states/run-{time_str}",
    max_iters=100,
    planner_mode="dynamic"             # åŠ¨æ€æ¨¡å¼
)
```

#### **1.2 MetaPlanner.__init__ å†…éƒ¨æµç¨‹**
```python
# _meta_planner.py ç¬¬200-280è¡Œ
def __init__(self, ...):
    # è°ƒç”¨çˆ¶ç±»ReActAgentåˆå§‹åŒ–
    super().__init__(
        name=name,
        sys_prompt=(
            "You are a helpful assistant named Task-Meta-Planner."
            "If a given task can not be done easily, then you may need "
            "to use the tool `enter_solving_complicated_task_mode` to "
            "change yourself to a more long-term planning mode."
        ),
        model=model,
        formatter=formatter,
        memory=memory,
        toolkit=toolkit,
        max_iters=max_iters,
    )
    
    # è®¾ç½®MetaPlannerç‰¹æœ‰å±æ€§
    self.agent_working_dir_root = agent_working_dir
    self.worker_full_toolkit = worker_full_toolkit
    self.state_saving_dir = state_saving_dir
    
    # åˆå§‹åŒ–è§„åˆ’å™¨ç»„ä»¶
    self.planner_notebook = PlannerNoteBook()  # ç©ºçš„è§„åˆ’ç¬”è®°æœ¬
    self.roadmap_manager = RoadmapManager(
        planner_notebook=self.planner_notebook
    )
    self.worker_manager = WorkerManager(
        worker_model=self.model,
        worker_formatter=self.formatter,
        planner_notebook=self.planner_notebook,
        agent_working_dir=self.task_dir,
        worker_full_toolkit=self.worker_full_toolkit,
    )
    
    # æ³¨å†Œè§„åˆ’å·¥å…·ï¼ˆåˆå§‹çŠ¶æ€ä¸ºç¦ç”¨ï¼‰
    self.prepare_planner_tools("dynamic")  # åŠ¨æ€æ¨¡å¼
```

#### **1.3 è§„åˆ’å·¥å…·å‡†å¤‡**
```python
# _meta_planner.py ç¬¬295-330è¡Œ
def prepare_planner_tools(self, planner_mode):
    # åˆ›å»ºå·¥å…·ç»„
    self.toolkit.create_tool_group("planning", "Tool group for planning capability")
    
    # æ³¨å†Œæ‰€æœ‰è§„åˆ’å·¥å…·å‡½æ•°
    self.toolkit.register_tool_function(
        self.roadmap_manager.decompose_task_and_build_roadmap,
        group_name="planning"
    )
    self.toolkit.register_tool_function(
        self.roadmap_manager.get_next_unfinished_subtask_from_roadmap,
        group_name="planning"
    )
    self.toolkit.register_tool_function(
        self.roadmap_manager.revise_roadmap,
        group_name="planning"
    )
    self.toolkit.register_tool_function(
        self.worker_manager.create_worker,
        group_name="planning"
    )
    self.toolkit.register_tool_function(
        self.worker_manager.execute_worker,
        group_name="planning"
    )
    self.toolkit.register_tool_function(
        self.worker_manager.show_current_worker_pool,
        group_name="planning"
    )
    
    if planner_mode == "dynamic":
        # åŠ¨æ€æ¨¡å¼ä¸‹ï¼Œè§„åˆ’å·¥å…·åˆå§‹ç¦ç”¨
        self.toolkit.update_tool_groups(["planning"], False)
        # æ³¨å†Œè¿›å…¥å¤æ‚ä»»åŠ¡æ¨¡å¼çš„å·¥å…·ï¼ˆè¿™ä¸ªæ˜¯æ¿€æ´»çš„ï¼‰
        self.toolkit.register_tool_function(
            self.enter_solving_complicated_task_mode
        )
```

---

### **é˜¶æ®µ2ï¼šç”¨æˆ·è¾“å…¥å¤„ç†**

#### **2.1 ç”¨æˆ·è¾“å…¥æ¥æ”¶**
```python
# main.py ä¸»å¾ªç¯
user = UserAgent("Bob")
msg = await user(msg)  # ä¾‹å¦‚ï¼š"è¯·ç ”ç©¶å¹¶ç¼–å†™AIå‘å±•å†å²æŠ¥å‘Š"
```

#### **2.2 MetaPlannerå¤„ç†è¾“å…¥**
```python
# è°ƒç”¨ ReActAgent.__call__ æ–¹æ³•
msg = await agent(msg)
```

#### **2.3 Pre-reply Hook æ‰§è¡Œ**
```python
# _meta_planner.py ç¬¬35-42è¡Œ
async def update_user_input_pre_reply_hook(self, kwargs):
    """Hook for loading user input to planner notebook"""
    msg = kwargs.get("msg", None)
    if isinstance(msg, Msg):
        msg = [msg]
    if isinstance(msg, list):
        for m in msg:
            # å°†ç”¨æˆ·è¾“å…¥æ·»åŠ åˆ°è§„åˆ’ç¬”è®°æœ¬
            self.planner_notebook.user_input.append(m.content)
```

---

### **é˜¶æ®µ3ï¼šä»»åŠ¡å¤æ‚åº¦åˆ¤æ–­**

#### **3.1 ReActæ¨ç†å¾ªç¯**
```python
# ReActAgentå†…éƒ¨æ¨ç†è¿‡ç¨‹
# 1. Pre-reasoning Hook
# 2. è°ƒç”¨æ¨¡å‹è¿›è¡Œæ¨ç†
# 3. Post-reasoning Hook
# 4. å·¥å…·è°ƒç”¨ï¼ˆå¦‚æœéœ€è¦ï¼‰
# 5. Post-action Hook
```

#### **3.2 æ¨¡å‹æ¨ç†åˆ¤æ–­**
æ¨¡å‹ä¼šåˆ†æç”¨æˆ·è¾“å…¥ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå¤æ‚ä»»åŠ¡ã€‚å¦‚æœåˆ¤æ–­ä¸ºå¤æ‚ä»»åŠ¡ï¼Œä¼šè°ƒç”¨å·¥å…·ï¼š

```python
# æ¨¡å‹è¾“å‡ºçš„å·¥å…·è°ƒç”¨
tool_call = {
    "type": "tool_use",
    "id": "tool_123",
    "name": "enter_solving_complicated_task_mode",
    "input": {
        "task_name": "ai_development_history_research"
    }
}
```

---

### **é˜¶æ®µ4ï¼šè¿›å…¥MetaPlanneræ¨¡å¼**

#### **4.1 enter_solving_complicated_task_mode è°ƒç”¨**
```python
# _meta_planner.py ç¬¬325-399è¡Œ
async def enter_solving_complicated_task_mode(self, task_name: str) -> ToolResponse:
    # 1. åˆ›å»ºä»»åŠ¡ç›®å½•
    self.task_dir = os.path.join(
        self.agent_working_dir_root,
        task_name  # "ai_development_history_research"
    )
    self.worker_manager.agent_working_dir = self.task_dir
    
    # 2. è°ƒç”¨å·¥å…·åˆ›å»ºç›®å½•
    create_task_dir = ToolUseBlock(
        type="tool_use",
        id=str(uuid.uuid4()),
        name="create_directory",
        input={"path": self.task_dir}
    )
    tool_res = await self.toolkit.call_tool_function(create_task_dir)
    
    # 3. æ›´æ–°ç³»ç»Ÿæç¤ºå’Œæ¿€æ´»è§„åˆ’å·¥å…·
    self._update_toolkit_and_sys_prompt()
    
    return ToolResponse(
        metadata={"success": True},
        content=[TextBlock(
            type="text",
            text=f"Successfully enter the planning-execution mode... {self.task_dir}"
        )]
    )
```

#### **4.2 _update_toolkit_and_sys_prompt å†…éƒ¨é€»è¾‘**
```python
# _meta_planner.py ç¬¬401-430è¡Œ
def _update_toolkit_and_sys_prompt(self):
    # 1. å‡†å¤‡å®Œæ•´å·¥å…·åˆ—è¡¨
    full_worker_tool_list = [
        {
            "tool_name": func_dict.get("function", {}).get("name", ""),
            "description": func_dict.get("function", {}).get("description", "")
        }
        for func_dict in self.worker_full_toolkit.get_json_schemas()
    ]
    
    # 2. æ›´æ–°è§„åˆ’ç¬”è®°æœ¬çš„å·¥å…·åˆ—è¡¨
    self.planner_notebook.full_tool_list = full_worker_tool_list
    
    # 3. åŠ è½½MetaPlannerç³»ç»Ÿæç¤º
    with open(
        Path(__file__).parent / "_built_in_long_sys_prompt" / "meta_planner_sys_prompt.md",
        "r", encoding="utf-8"
    ) as f:
        sys_prompt = f.read()
    
    # 4. æ ¼å¼åŒ–ç³»ç»Ÿæç¤ºï¼ˆæ³¨å…¥å·¥å…·åˆ—è¡¨ï¼‰
    sys_prompt = sys_prompt.format_map({
        "tool_list": json.dumps(full_worker_tool_list, ensure_ascii=False)
    })
    
    # 5. æ›´æ–°ç³»ç»Ÿæç¤º
    self._sys_prompt = sys_prompt
    
    # 6. æ¿€æ´»è§„åˆ’å·¥å…·ç»„
    self.toolkit.update_tool_groups(["planning"], True)
    
    # 7. æ ‡è®°è¿›å…¥è§„åˆ’æ¨¡å¼
    self.in_planner_mode = True
```

---

### **é˜¶æ®µ5ï¼šä»»åŠ¡åˆ†è§£**

#### **5.1 æ¨¡å‹æ¨ç†å†³å®šåˆ†è§£ä»»åŠ¡**
```python
# æ¨¡å‹è¾“å‡ºåˆ†è§£ä»»åŠ¡çš„å·¥å…·è°ƒç”¨
tool_call = {
    "type": "tool_use", 
    "id": "tool_456",
    "name": "decompose_task_and_build_roadmap",
    "input": {
        "user_latest_input": "è¯·ç ”ç©¶å¹¶ç¼–å†™AIå‘å±•å†å²æŠ¥å‘Š",
        "given_task_conclusion": "ç”Ÿæˆä¸€ä»½å…³äºAIå‘å±•å†å²çš„ç»¼åˆç ”ç©¶æŠ¥å‘Šï¼ŒåŒ…æ‹¬æŠ€æœ¯çªç ´ã€å…³é”®äººç‰©ã€åº”ç”¨é¢†åŸŸå’Œæœªæ¥è¶‹åŠ¿",
        "detail_analysis_for_plan": "è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç ”ç©¶ä»»åŠ¡ï¼Œéœ€è¦æ”¶é›†å†å²æ•°æ®ã€åˆ†æå…³é”®äººç‰©ã€ç ”ç©¶åº”ç”¨å‘å±•ï¼Œæœ€åæ•´åˆæˆæŠ¥å‘Šã€‚éœ€è¦åˆ†æ­¥éª¤è¿›è¡Œï¼Œç¡®ä¿ä¿¡æ¯å‡†ç¡®æ€§å’Œå®Œæ•´æ€§ã€‚",
        "decomposed_subtasks": [
            {
                "subtask_description": "æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®",
                "input_intro": "éœ€è¦ä»äº’è”ç½‘æœç´¢AIå‘å±•çš„é‡è¦é‡Œç¨‹ç¢‘",
                "exact_input": "ä½¿ç”¨tavilyæœç´¢å·¥å…·æœç´¢AIå†å²å‘å±•çš„é‡è¦æŠ€æœ¯çªç ´ï¼Œæ—¶é—´è·¨åº¦ä»1950å¹´åˆ°2024å¹´",
                "expected_output": "æŒ‰æ—¶é—´é¡ºåºæ’åˆ—çš„AIæŠ€æœ¯çªç ´äº‹ä»¶åˆ—è¡¨ï¼ŒåŒ…æ‹¬æ—¶é—´ã€äº‹ä»¶æè¿°ã€å½±å“ç¨‹åº¦",
                "desired_auxiliary_tools": ["tavily_search", "write_file", "read_file"]
            },
            {
                "subtask_description": "æ•´ç†AIé¢†åŸŸå…³é”®äººç‰©åŠå…¶è´¡çŒ®",
                "input_intro": "åŸºäºæ”¶é›†çš„æŠ€æœ¯çªç ´ä¿¡æ¯ï¼Œåˆ†æç›¸å…³çš„ç ”ç©¶äººå‘˜",
                "exact_input": "æœç´¢å¹¶åˆ†æAIé¢†åŸŸçš„é‡è¦ç ”ç©¶äººç‰©ï¼ŒåŒ…æ‹¬ä»–ä»¬çš„æ•™è‚²èƒŒæ™¯ã€ä¸»è¦è´¡çŒ®ã€å½±å“é¢†åŸŸ",
                "expected_output": "AIé¢†åŸŸå…³é”®äººç‰©æ¸…å•ï¼ŒåŒ…æ‹¬äººç‰©ç®€ä»‹ã€ä¸»è¦è´¡çŒ®ã€ç›¸å…³è®ºæ–‡ã€å½±å“è¯„ä»·",
                "desired_auxiliary_tools": ["tavily_search", "write_file", "read_file"]
            },
            {
                "subtask_description": "åˆ†æAIåº”ç”¨é¢†åŸŸå‘å±•å†ç¨‹", 
                "input_intro": "ç ”ç©¶AIåœ¨å„ä¸ªåº”ç”¨é¢†åŸŸçš„å‘å±•è½¨è¿¹",
                "exact_input": "æœç´¢AIåœ¨åŒ»ç–—ã€é‡‘èã€æ•™è‚²ã€äº¤é€šç­‰ä¸»è¦åº”ç”¨é¢†åŸŸçš„å‘å±•å†ç¨‹å’Œç°çŠ¶",
                "expected_output": "å„åº”ç”¨é¢†åŸŸå‘å±•åˆ†ææŠ¥å‘Šï¼ŒåŒ…æ‹¬å‘å±•æ—¶é—´çº¿ã€é‡è¦åº”ç”¨ã€å¸‚åœºè§„æ¨¡ã€æœªæ¥è¶‹åŠ¿",
                "desired_auxiliary_tools": ["tavily_search", "write_file", "read_file"]
            },
            {
                "subtask_description": "æ•´åˆä¿¡æ¯ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š",
                "input_intro": "å°†å‰é¢ä¸‰ä¸ªå­ä»»åŠ¡çš„ç»“æœæ•´åˆæˆå®Œæ•´æŠ¥å‘Š",
                "exact_input": "è¯»å–å‰ä¸‰ä¸ªå­ä»»åŠ¡ç”Ÿæˆçš„æ‰€æœ‰æ–‡ä»¶ï¼Œåˆ†ææ•´åˆä¿¡æ¯ï¼Œç”Ÿæˆç»“æ„åŒ–çš„AIå‘å±•å†å²æŠ¥å‘Š",
                "expected_output": "å®Œæ•´çš„AIå‘å±•å†å²æŠ¥å‘Šï¼ŒåŒ…å«æ‘˜è¦ã€æŠ€æœ¯å‘å±•ã€äººç‰©è´¡çŒ®ã€åº”ç”¨åˆ†æã€æœªæ¥è¶‹åŠ¿ç­‰ç« èŠ‚",
                "desired_auxiliary_tools": ["read_file", "write_file", "edit_file"]
            }
        ]
    }
}
```

#### **5.2 decompose_task_and_build_roadmap æ‰§è¡Œ**
```python
# _roadmap_manager.py ç¬¬23-67è¡Œ
async def decompose_task_and_build_roadmap(
    self,
    user_latest_input: str,
    given_task_conclusion: str, 
    detail_analysis_for_plan: str,
    decomposed_subtasks: list[SubTaskSpecification]
) -> ToolResponse:
    
    # 1. ä¿å­˜åˆ†æä¿¡æ¯
    self.planner_notebook.detail_analysis_for_plan = detail_analysis_for_plan
    self.planner_notebook.roadmap.original_task = given_task_conclusion
    
    # 2. å¤„ç†æ¯ä¸ªå­ä»»åŠ¡
    for subtask in decomposed_subtasks:
        # è½¬æ¢æ•°æ®æ ¼å¼
        if isinstance(subtask, dict):
            subtask_status = SubTaskStatus(
                subtask_specification=SubTaskSpecification(**subtask)
            )
        elif isinstance(subtask, SubTaskSpecification):
            subtask_status = SubTaskStatus(subtask_specification=subtask)
        
        # æ·»åŠ åˆ°è·¯æ ‡
        self.planner_notebook.roadmap.decomposed_tasks.append(subtask_status)
    
    # 3. ä¿å­˜ç”¨æˆ·è¾“å…¥
    self.planner_notebook.user_input.append(user_latest_input)
    
    return ToolResponse(
        metadata={"success": True},
        content=[TextBlock(
            type="text",
            text="Successfully decomposed the task into subtasks"
        )]
    )
```

#### **5.3 PlannerNoteBookçŠ¶æ€æ›´æ–°**
```python
# _planning_notebook.py ç¬¬300-325è¡Œ
class PlannerNoteBook(BaseModel):
    time: str = get_current_time_message()
    user_input: List[str] = ["è¯·ç ”ç©¶å¹¶ç¼–å†™AIå‘å±•å†å²æŠ¥å‘Š"]
    detail_analysis_for_plan: "è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç ”ç©¶ä»»åŠ¡..."
    roadmap: RoadMap = RoadMap(
        original_task="ç”Ÿæˆä¸€ä»½å…³äºAIå‘å±•å†å²çš„ç»¼åˆç ”ç©¶æŠ¥å‘Š...",
        decomposed_tasks=[
            SubTaskStatus(
                subtask_specification=SubTaskSpecification(
                    subtask_description="æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®",
                    # ... å…¶ä»–å±æ€§
                ),
                status="Planned",
                updates=[],
                attempt=0,
                workers=[]
            ),
            # ... å…¶ä»–3ä¸ªå­ä»»åŠ¡
        ]
    )
    files: Dict[str, str] = {}
    full_tool_list: list[dict] = [...]
```

---

### **é˜¶æ®µ6ï¼šè·å–ä¸‹ä¸€ä¸ªæœªå®Œæˆå­ä»»åŠ¡**

#### **6.1 æ¨¡å‹æ¨ç†è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡**
```python
# æ¨¡å‹è¾“å‡º
tool_call = {
    "type": "tool_use",
    "id": "tool_789", 
    "name": "get_next_unfinished_subtask_from_roadmap",
    "input": {}
}
```

#### **6.2 get_next_unfinished_subtask_from_roadmap æ‰§è¡Œ**
```python
# _roadmap_manager.py ç¬¬69-95è¡Œ
async def get_next_unfinished_subtask_from_roadmap(self) -> ToolResponse:
    # 1. æŸ¥æ‰¾ä¸‹ä¸€ä¸ªæœªå®Œæˆçš„å­ä»»åŠ¡
    idx, subtask = self.planner_notebook.roadmap.next_unfinished_subtask()
    
    # 2. æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆä»»åŠ¡
    if idx is None or subtask is None:
        return ToolResponse(
            metadata={"success": False},
            content=[TextBlock(
                type="text",
                text="No unfinished subtask was found. Either all subtasks have been done, or the task has not been decomposed."
            )]
        )
    
    # 3. è¿”å›æœªå®Œæˆä»»åŠ¡
    return ToolResponse(
        metadata={
            "success": True, 
            "subtask": subtask.model_dump()
        },
        content=[
            TextBlock(type="text", text=f"Next unfinished subtask idx: {idx}"),
            TextBlock(type="text", text=subtask.model_dump_json(indent=2))
        ]
    )

# RoadMap.next_unfinished_subtask å®ç°
def next_unfinished_subtask(self) -> Tuple[Optional[int], Optional[SubTaskStatus]]:
    """æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœªå®Œæˆçš„å­ä»»åŠ¡"""
    for i, subtask in enumerate(self.decomposed_tasks):
        if subtask.status in ["Planned", "In-process"]:
            return i, subtask
    return None, None
```

#### **6.3 è¿”å›ç¬¬ä¸€ä¸ªå­ä»»åŠ¡**
```json
{
    "metadata": {
        "success": true,
        "subtask": {
            "subtask_specification": {
                "subtask_description": "æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®",
                "input_intro": "éœ€è¦ä»äº’è”ç½‘æœç´¢AIå‘å±•çš„é‡è¦é‡Œç¨‹ç¢‘",
                "exact_input": "ä½¿ç”¨tavilyæœç´¢å·¥å…·æœç´¢AIå†å²å‘å±•çš„é‡è¦æŠ€æœ¯çªç ´...",
                "expected_output": "æŒ‰æ—¶é—´é¡ºåºæ’åˆ—çš„AIæŠ€æœ¯çªç ´äº‹ä»¶åˆ—è¡¨...",
                "desired_auxiliary_tools": ["tavily_search", "write_file", "read_file"]
            },
            "status": "Planned",
            "updates": [],
            "attempt": 0,
            "workers": []
        }
    },
    "content": [
        {"type": "text", "text": "Next unfinished subtask idx: 0"},
        {"type": "text", "text": "{...subtask_json...}"}
    ]
}
```

---

### **é˜¶æ®µ7ï¼šåˆ›å»ºä¸“é—¨çš„Worker Agent**

#### **7.1 æ¨¡å‹æ¨ç†å†³å®šåˆ›å»ºWorker**
```python
# æ¨¡å‹è¾“å‡ºåˆ›å»ºWorkerçš„å·¥å…·è°ƒç”¨
tool_call = {
    "type": "tool_use",
    "id": "tool_101112",
    "name": "create_worker", 
    "input": {
        "worker_name": "history_researcher",
        "worker_system_prompt": "ä½ æ˜¯AIå†å²ç ”ç©¶ä¸“å®¶ï¼Œä¸“é—¨è´Ÿè´£æ”¶é›†å’Œæ•´ç†AIå‘å±•å²ç›¸å…³èµ„æ–™ã€‚ä½ éœ€è¦ä½¿ç”¨æœç´¢å·¥å…·æ‰¾åˆ°å‡†ç¡®çš„å†å²ä¿¡æ¯ï¼Œå¹¶æŒ‰ç…§æ—¶é—´é¡ºåºæ•´ç†æˆç»“æ„åŒ–çš„æ–‡æ¡£ã€‚",
        "tool_names": ["tavily_search", "write_file", "read_file"],
        "agent_description": "ä¸“é—¨è´Ÿè´£AIå†å²æ•°æ®æ”¶é›†å’Œæ•´ç†çš„ç ”ç©¶å‘˜"
    }
}
```

#### **7.2 create_worker è¯¦ç»†æ‰§è¡Œæµç¨‹**
```python
# _worker_manager.py ç¬¬266-399è¡Œ
async def create_worker(
    self,
    worker_name: str,
    worker_system_prompt: str, 
    tool_names: Optional[List[str]] = None,
    agent_description: str = ""
) -> ToolResponse:
    
    # 1. å¤„ç†å·¥å…·åç§°å‚æ•°
    if tool_names is None:
        tool_names = []
    elif isinstance(tool_names, str):
        tool_names = json.loads(tool_names)
    
    # 2. åˆ›å»ºWorkerä¸“ç”¨å·¥å…·åŒ…
    worker_toolkit = Toolkit()
    
    # 3. åˆ†é…å·¥å…·ç»™Worker
    share_tools(
        self.worker_full_toolkit,
        worker_toolkit,
        tool_names + [  # æ·»åŠ åŸºç¡€æ–‡ä»¶æ“ä½œå·¥å…·
            "read_file", "write_file", "edit_file", 
            "search_files", "list_directory"
        ]
    )
    
    # 4. åŠ è½½Workeré™„åŠ ç³»ç»Ÿæç¤º
    with open(
        Path(__file__).parent.parent / "_built_in_long_sys_prompt" / "_worker_additional_sys_prompt.md",
        "r", encoding="utf-8"
    ) as f:
        additional_worker_prompt = f.read()
    
    with open(
        Path(__file__).parent.parent / "_built_in_long_sys_prompt" / "_tool_usage_rules.md",
        "r", encoding="utf-8" 
    ) as f:
        additional_worker_prompt += f.read().format_map({
            "agent_working_dir": self.agent_working_dir
        })
    
    # 5. åˆ›å»ºReActAgent Workerå®ä¾‹
    worker = ReActAgent(
        name=worker_name,
        sys_prompt=(worker_system_prompt + additional_worker_prompt),
        model=self.worker_model,
        formatter=self.worker_formatter,
        memory=InMemoryMemory(),  # Workerç‹¬ç«‹çš„å†…å­˜
        toolkit=worker_toolkit,
    )
    
    # 6. æ³¨å†ŒWorkeråˆ°Workeræ± 
    self._register_worker(
        worker,
        description=agent_description,
        worker_type="dynamic-built"
    )
    
    return ToolResponse(
        metadata={"success": True},
        content=[TextBlock(
            type="text",
            text=f"Successfully created a worker agent:\n"
                 f"Worker name: {worker_name}\n"
                 f"Worker tools: {tool_names}\n"
                 f"Worker system prompt: {worker.sys_prompt}"
        )]
    )
```

#### **7.3 share_tools å·¥å…·å…±äº«æœºåˆ¶**
```python
# _worker_manager.py ç¬¬165-186è¡Œ
def share_tools(old_toolkit: Toolkit, new_toolkit: Toolkit, tool_list: list[str]):
    """å°†æŒ‡å®šå·¥å…·ä»æ—§å·¥å…·åŒ…å…±äº«åˆ°æ–°å·¥å…·åŒ…"""
    for tool in tool_list:
        if tool in old_toolkit.tools and tool not in new_toolkit.tools:
            # å¤åˆ¶å·¥å…·å‡½æ•°
            new_toolkit.tools[tool] = old_toolkit.tools[tool]
        else:
            logger.warning(f"No tool {tool} in the provided worker_tool_toolkit")
```

#### **7.4 _register_worker Workeræ³¨å†Œ**
```python
# _worker_manager.py ç¬¬100-130è¡Œ
def _register_worker(
    self,
    agent: ReActAgent,
    description: Optional[str] = None,
    worker_type: Literal["built-in", "dynamic-built"] = "dynamic"
) -> None:
    # 1. åˆ›å»ºWorkerä¿¡æ¯
    worker_info = WorkerInfo(
        worker_name=agent.name,
        description=description,
        worker_type=worker_type,
        status="ready-to-work"
    )
    
    # 2. åŠ¨æ€åˆ›å»ºçš„Workeréœ€è¦ä¿å­˜é¢å¤–ä¿¡æ¯
    if worker_type == "dynamic-built":
        worker_info.sys_prompt = agent.sys_prompt
        worker_info.tool_lists = list(agent.toolkit.tools.keys())
    
    # 3. å¤„ç†åç§°å†²çª
    if agent.name in self.worker_pool:
        name = agent.name
        version = 1
        while name in self.worker_pool:
            name = agent.name + f"_v{version}"
            version += 1
        agent.name, worker_info.worker_name = name, name
        self.worker_pool[name] = (worker_info, agent)
    else:
        self.worker_pool[agent.name] = (worker_info, agent)
```

#### **7.5 WorkerManagerçŠ¶æ€æ›´æ–°**
```python
# WorkerManagerç°åœ¨åŒ…å«ï¼š
self.worker_pool = {
    "history_researcher": (
        WorkerInfo(
            worker_name="history_researcher",
            description="ä¸“é—¨è´Ÿè´£AIå†å²æ•°æ®æ”¶é›†å’Œæ•´ç†çš„ç ”ç©¶å‘˜",
            worker_type="dynamic-built",
            status="ready-to-work",
            tool_lists=["tavily_search", "write_file", "read_file", "search_files", "list_directory"],
            sys_prompt="ä½ æ˜¯AIå†å²ç ”ç©¶ä¸“å®¶..." + additional_worker_prompt
        ),
        ReActAgent(...)  # å®é™…çš„Agentå®ä¾‹
    )
}
```

---

### **é˜¶æ®µ8ï¼šæ‰§è¡ŒWorkerä»»åŠ¡**

#### **8.1 æ¨¡å‹æ¨ç†æ‰§è¡ŒWorker**
```python
# æ¨¡å‹è¾“å‡ºæ‰§è¡ŒWorkerçš„å·¥å…·è°ƒç”¨
tool_call = {
    "type": "tool_use",
    "id": "tool_131415",
    "name": "execute_worker",
    "input": {
        "subtask_idx": 0,
        "selected_worker_name": "history_researcher", 
        "detailed_instruction": "è¯·ä½¿ç”¨tavily_searchå·¥å…·æœç´¢AIå‘å±•å†å²çš„é‡è¦æŠ€æœ¯çªç ´ï¼Œä»1950å¹´çš„è¾¾ç‰¹èŒ…æ–¯ä¼šè®®å¼€å§‹ï¼Œåˆ°2024å¹´çš„æœ€æ–°å‘å±•ã€‚é‡ç‚¹å…³æ³¨ï¼š1) äººå·¥æ™ºèƒ½æ¦‚å¿µçš„æå‡º 2) ä¸“å®¶ç³»ç»Ÿçš„å…´èµ· 3) æœºå™¨å­¦ä¹ çš„å‘å±• 4) æ·±åº¦å­¦ä¹ é©å‘½ 5) å¤§è¯­è¨€æ¨¡å‹çš„å‡ºç°ã€‚è¯·å°†æœç´¢ç»“æœæŒ‰æ—¶é—´é¡ºåºæ•´ç†ï¼Œæ¯ä¸ªäº‹ä»¶åŒ…æ‹¬æ—¶é—´ã€äº‹ä»¶æè¿°ã€ä¸»è¦äººç‰©ã€æŠ€æœ¯æ„ä¹‰ã€‚å°†ç»“æœä¿å­˜ä¸ºmarkdownæ–‡ä»¶ï¼Œæ–‡ä»¶åä¸ºai_technology_timeline.md"
    }
}
```

#### **8.2 execute_worker è¯¦ç»†æ‰§è¡Œæµç¨‹**
```python
# _worker_manager.py ç¬¬482-549è¡Œ
async def execute_worker(
    self,
    subtask_idx: int,
    selected_worker_name: str,
    detailed_instruction: str
) -> ToolResponse:
    
    # 1. éªŒè¯Workeræ˜¯å¦å­˜åœ¨
    if selected_worker_name not in self.worker_pool:
        worker_info = {
            name: info 
            for name, (info, _) in self.worker_pool.items()
        }
        current_agent_pool = json.dumps(worker_info, ensure_ascii=False, indent=2)
        return ToolResponse(
            metadata={"success": False},
            content=[TextBlock(
                type="text", 
                text=f"There is no {selected_worker_name} in current agent pool.\n"
                     f"Current agent pool:\n```json\n{current_agent_pool}\n```"
            )]
        )
    
    # 2. è·å–Workerå®ä¾‹
    worker = self.worker_pool[selected_worker_name][1]
    
    # 3. æ„å»ºä»»åŠ¡æ¶ˆæ¯
    question_msg = Msg(
        role="user",
        name="user", 
        content=detailed_instruction
    )
    
    # 4. æ‰§è¡ŒWorkerï¼ˆè¦æ±‚ç»“æ„åŒ–è¾“å‡ºï¼‰
    worker_response_msg = await worker(
        question_msg,
        structured_model=WorkerResponse  # è¦æ±‚è¿”å›WorkerResponseæ ¼å¼
    )
    
    # 5. å¤„ç†Workerå“åº”
    if worker_response_msg.metadata is not None:
        # è§£æ„WorkerResponse
        worker_response = WorkerResponse(**worker_response_msg.metadata)
        
        # 6. å°†Workerä¿¡æ¯æ·»åŠ åˆ°å­ä»»åŠ¡
        self.planner_notebook.roadmap.decomposed_tasks[subtask_idx].workers.append(
            self.worker_pool[selected_worker_name][0]
        )
        
        # 7. éªŒè¯å¹¶è®°å½•ç”Ÿæˆçš„æ–‡ä»¶
        for filepath, desc in worker_response.generated_files.items():
            if await check_file_existence(filepath, self.worker_full_toolkit):
                self.planner_notebook.files[filepath] = desc
            else:
                worker_response.generated_files.pop(filepath)
        
        return ToolResponse(
            metadata={
                "success": True,
                "worker_response": worker_response.model_dump_json()
            },
            content=[TextBlock(
                type="text",
                text=worker_response.model_dump_json()
            )]
        )
    else:
        return ToolResponse(
            metadata={
                "success": False,
                "worker_response": worker_response_msg.content
            },
            content=[TextBlock(
                type="text",
                text=str(worker_response_msg.content)
            )]
        )
```

#### **8.3 Workerå†…éƒ¨æ‰§è¡Œè¿‡ç¨‹**
Workerä½œä¸ºReActAgentï¼Œä¼šæ‰§è¡Œæ ‡å‡†çš„æ¨ç†-è¡ŒåŠ¨å¾ªç¯ï¼š

```python
# Worker ReActAgentå†…éƒ¨æ‰§è¡Œ
# 1. æ¥æ”¶ä»»åŠ¡æŒ‡ä»¤
# 2. æ¨ç†ï¼šéœ€è¦ä½¿ç”¨tavily_searchæœç´¢AIå†å²
# 3. è¡ŒåŠ¨ï¼šè°ƒç”¨tavily_searchå·¥å…·
# 4. è§‚å¯Ÿç»“æœï¼Œç»§ç»­æ¨ç†
# 5. è¡ŒåŠ¨ï¼šè°ƒç”¨write_fileå·¥å…·ä¿å­˜ç»“æœ
# 6. æœ€ç»ˆç”ŸæˆWorkerResponse
```

#### **8.4 Workerå†…éƒ¨å·¥å…·è°ƒç”¨ç¤ºä¾‹**
```python
# Workerè°ƒç”¨tavily_search
search_tool_call = {
    "type": "tool_use",
    "name": "tavily_search",
    "input": {
        "query": "artificial intelligence history major breakthroughs 1950-2024"
    }
}

# Workerè°ƒç”¨write_fileä¿å­˜ç»“æœ
write_tool_call = {
    "type": "tool_use", 
    "name": "write_file",
    "input": {
        "path": "ai_technology_timeline.md",
        "content": "# AIæŠ€æœ¯å‘å±•æ—¶é—´çº¿\n\n## 1956å¹´ï¼šè¾¾ç‰¹èŒ…æ–¯ä¼šè®®\näººå·¥æ™ºèƒ½æ¦‚å¿µæ­£å¼æå‡º...\n\n## 1957å¹´ï¼šPerceptron\nFrank Rosenblattå‘æ˜æ„ŸçŸ¥æœº..."
    }
}
```

#### **8.5 Workerç”Ÿæˆç»“æ„åŒ–å“åº”**
```python
# Workeræœ€ç»ˆè¾“å‡º
worker_response = WorkerResponse(
    subtask_progress_summary="""
## ä»»åŠ¡æ¦‚è¿°
ç”¨æˆ·è¦æ±‚æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®ï¼Œç”Ÿæˆæ—¶é—´çº¿æŠ¥å‘Šã€‚

## æ‰§è¡Œè¿‡ç¨‹
1. ä½¿ç”¨tavily_searchæœç´¢äº†AIå‘å±•å†å²çš„å…³é”®äº‹ä»¶
2. é‡ç‚¹æ”¶é›†äº†1956å¹´è¾¾ç‰¹èŒ…æ–¯ä¼šè®®ã€1980å¹´ä»£ä¸“å®¶ç³»ç»Ÿã€2006å¹´æ·±åº¦å­¦ä¹ çªç ´ã€2018å¹´Transformerç­‰é‡è¦èŠ‚ç‚¹
3. æŒ‰æ—¶é—´é¡ºåºæ•´ç†äº†50ä¸ªå…³é”®æŠ€æœ¯çªç ´
4. ç”Ÿæˆäº†å®Œæ•´çš„markdownæ—¶é—´çº¿æ–‡æ¡£

## å®Œæˆæƒ…å†µæ£€æŸ¥
- [x] æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®
- [x] æŒ‰æ—¶é—´é¡ºåºæ’åˆ—äº‹ä»¶ 
- [x] åŒ…å«äº‹ä»¶æè¿°å’Œæ„ä¹‰åˆ†æ
- [x] ä¿å­˜ä¸ºmarkdownæ–‡ä»¶

## ç»“è®º
ä»»åŠ¡å·²åœ†æ»¡å®Œæˆï¼Œç”Ÿæˆäº†è¯¦ç»†çš„AIæŠ€æœ¯å‘å±•æ—¶é—´çº¿æ–‡æ¡£ã€‚
""",
    next_step="",  # ä»»åŠ¡å·²å®Œæˆï¼Œæ— ä¸‹ä¸€æ­¥
    generated_files={
        "ai_technology_timeline.md": "AIæŠ€æœ¯å‘å±•æ—¶é—´çº¿æ–‡æ¡£ï¼ŒåŒ…å«1950-2024å¹´é‡è¦æŠ€æœ¯çªç ´"
    },
    task_done=True
)
```

---

### **é˜¶æ®µ9ï¼šæ›´æ–°ä»»åŠ¡çŠ¶æ€**

#### **9.1 æ¨¡å‹æ¨ç†æ›´æ–°è·¯æ ‡**
```python
# æ¨¡å‹è¾“å‡ºæ›´æ–°è·¯æ ‡çš„å·¥å…·è°ƒç”¨
tool_call = {
    "type": "tool_use",
    "id": "tool_161718",
    "name": "revise_roadmap",
    "input": {
        "action": "revise_subtask",
        "subtask_idx": 0,
        "subtask_specification": {
            "subtask_description": "æ”¶é›†AIæŠ€æœ¯çªç ´å†å²æ•°æ®",
            "input_intro": "éœ€è¦ä»äº’è”ç½‘æœç´¢AIå‘å±•çš„é‡è¦é‡Œç¨‹ç¢‘",
            "exact_input": "ä½¿ç”¨tavilyæœç´¢å·¥å…·æœç´¢AIå†å²å‘å±•çš„é‡è¦æŠ€æœ¯çªç ´ï¼Œæ—¶é—´è·¨åº¦ä»1950å¹´åˆ°2024å¹´",
            "expected_output": "æŒ‰æ—¶é—´é¡ºåºæ’åˆ—çš„AIæŠ€æœ¯çªç ´äº‹ä»¶åˆ—è¡¨ï¼ŒåŒ…æ‹¬æ—¶é—´ã€äº‹ä»¶æè¿°ã€å½±å“ç¨‹åº¦",
            "desired_auxiliary_tools": ["tavily_search", "write_file", "read_file"]
        },
        "update_to_subtask": {
            "reason_for_status": "Worker history_researcher æˆåŠŸå®Œæˆäº†AIæŠ€æœ¯å†å²æ•°æ®çš„æ”¶é›†å’Œæ•´ç†ï¼Œç”Ÿæˆäº†å®Œæ•´çš„æ—¶é—´çº¿æ–‡æ¡£",
            "task_done": True,
            "subtask_progress_summary": "æˆåŠŸæ”¶é›†äº†AIå‘å±•å†å²çš„50ä¸ªé‡è¦æŠ€æœ¯çªç ´ï¼Œä»1956å¹´è¾¾ç‰¹èŒ…æ–¯ä¼šè®®åˆ°2024å¹´æœ€æ–°è¿›å±•ï¼Œç”Ÿæˆäº†è¯¦ç»†çš„markdownæ—¶é—´çº¿æ–‡æ¡£",
            "next_step": "",
            "worker": "history_researcher",
            "attempt_idx": 1
        },
        "new_status": "Done"
    }
}
```

#### **9.2 revise_roadmap æ‰§è¡Œ**
```python
# _roadmap_manager.py ç¬¬97-280è¡Œ
async def revise_roadmap(
    self,
    action: Literal["add_subtask", "revise_subtask", "remove_subtask"],
    subtask_idx: int,
    subtask_specification: Optional[SubTaskSpecification] = None,
    update_to_subtask: Optional[Update] = None,
    new_status: Literal["Planned", "In-process", "Done"] = "In-process"
) -> ToolResponse:
    
    # 1. éªŒè¯å­ä»»åŠ¡ç´¢å¼•
    num_subtasks = len(self.planner_notebook.roadmap.decomposed_tasks)
    if subtask_idx >= num_subtasks:
        return ToolResponse(
            metadata={"success": False},
            content=[TextBlock(
                type="text",
                text=f"Invalid subtask_idx {subtask_idx}, max is {num_subtasks-1}"
            )]
        )
    
    # 2. å¤„ç†ä¸åŒæ“ä½œ
    if action == "revise_subtask":
        # 3. æ›´æ–°å­ä»»åŠ¡è§„æ ¼
        if subtask_specification is not None:
            if isinstance(subtask_specification, dict):
                subtask_specification = SubTaskSpecification(**subtask_specification)
            self.planner_notebook.roadmap.decomposed_tasks[
                subtask_idx
            ].subtask_specification = subtask_specification
        
        # 4. æ·»åŠ æ›´æ–°è®°å½•
        if update_to_subtask is not None:
            if isinstance(update_to_subtask, dict):
                update_to_subtask = Update(**update_to_subtask)
            
            # å¢åŠ å°è¯•æ¬¡æ•°
            self.planner_notebook.roadmap.decomposed_tasks[subtask_idx].attempt += 1
            
            # æ·»åŠ æ›´æ–°è®°å½•
            self.planner_notebook.roadmap.decomposed_tasks[
                subtask_idx
            ].updates.append(update_to_subtask)
        
        # 5. æ›´æ–°çŠ¶æ€
        self.planner_notebook.roadmap.decomposed_tasks[subtask_idx].status = new_status
    
    return ToolResponse(
        metadata={"success": True},
        content=[TextBlock(
            type="text",
            text=f"Successfully revised subtask {subtask_idx} with action {action}"
        )]
    )
```

#### **9.3 PlannerNoteBookçŠ¶æ€æ›´æ–°**
```python
# æ›´æ–°åçš„ç¬¬ä¸€ä¸ªå­ä»»åŠ¡çŠ¶æ€
decomposed_tasks[0] = SubTaskStatus(
    subtask_specification=SubTaskSpecification(...),  # ä¿æŒä¸å˜
    status="Done",  # çŠ¶æ€æ›´æ–°ä¸ºå®Œæˆ
    updates=[Update(  # æ·»åŠ æ›´æ–°è®°å½•
        reason_for_status="Worker history_researcher æˆåŠŸå®Œæˆäº†AIæŠ€æœ¯å†å²æ•°æ®çš„æ”¶é›†å’Œæ•´ç†...",
        task_done=True,
        subtask_progress_summary="æˆåŠŸæ”¶é›†äº†AIå‘å±•å†å²çš„50ä¸ªé‡è¦æŠ€æœ¯çªç ´...",
        next_step="",
        worker="history_researcher",
        attempt_idx=1
    )],
    attempt=1,  # å°è¯•æ¬¡æ•°
    workers=[WorkerInfo(  # æ·»åŠ Workerä¿¡æ¯
        worker_name="history_researcher",
        description="ä¸“é—¨è´Ÿè´£AIå†å²æ•°æ®æ”¶é›†å’Œæ•´ç†çš„ç ”ç©¶å‘˜",
        worker_type="dynamic-built",
        status="ready-to-work",
        tool_lists=["tavily_search", "write_file", "read_file", "search_files", "list_directory"],
        sys_prompt="ä½ æ˜¯AIå†å²ç ”ç©¶ä¸“å®¶..."
    )]
)
```

---

### **é˜¶æ®µ10ï¼šç»§ç»­ä¸‹ä¸€ä¸ªå­ä»»åŠ¡**

#### **10.1 å¾ªç¯å¤„ç†å‰©ä½™å­ä»»åŠ¡**
ç³»ç»Ÿä¼šé‡å¤é˜¶æ®µ6-9ï¼Œä¾æ¬¡å¤„ç†ï¼š

**å­ä»»åŠ¡2ï¼šæ•´ç†AIé¢†åŸŸå…³é”®äººç‰©**
```python
# åˆ›å»ºäººç‰©åˆ†æWorker
person_analyst = await create_worker(
    worker_name="person_analyst",
    worker_system_prompt="ä½ æ˜¯AIé¢†åŸŸä¸“å®¶ï¼Œä¸“é—¨ç ”ç©¶AIé¢†åŸŸé‡è¦äººç‰©çš„è´¡çŒ®...",
    tool_names=["tavily_search", "write_file", "read_file"],
    agent_description="ä¸“é—¨è´Ÿè´£AIé¢†åŸŸäººç‰©åˆ†æçš„ç ”ç©¶å‘˜"
)

# æ‰§è¡Œäººç‰©åˆ†æä»»åŠ¡
await execute_worker(
    subtask_idx=1,
    selected_worker_name="person_analyst", 
    detailed_instruction="æœç´¢å¹¶åˆ†æAIé¢†åŸŸçš„é‡è¦ç ”ç©¶äººç‰©..."
)

# æ›´æ–°ä»»åŠ¡çŠ¶æ€
await revise_roadmap(
    action="revise_subtask",
    subtask_idx=1,
    new_status="Done",
    update_to_subtask={...}
)
```

**å­ä»»åŠ¡3ï¼šåˆ†æAIåº”ç”¨é¢†åŸŸå‘å±•**
```python
# åˆ›å»ºåº”ç”¨åˆ†æWorker
app_analyst = await create_worker(
    worker_name="app_analyst", 
    worker_system_prompt="ä½ æ˜¯AIåº”ç”¨é¢†åŸŸåˆ†æä¸“å®¶ï¼Œä¸“é—¨ç ”ç©¶AIåœ¨å„è¡Œä¸šåº”ç”¨çš„å‘å±•å†ç¨‹...",
    tool_names=["tavily_search", "write_file", "read_file"],
    agent_description="ä¸“é—¨è´Ÿè´£AIåº”ç”¨é¢†åŸŸå‘å±•åˆ†æçš„ç ”ç©¶å‘˜"
)

# æ‰§è¡Œåº”ç”¨åˆ†æä»»åŠ¡
await execute_worker(
    subtask_idx=2,
    selected_worker_name="app_analyst",
    detailed_instruction="ç ”ç©¶AIåœ¨åŒ»ç–—ã€é‡‘èã€æ•™è‚²ã€äº¤é€šç­‰ä¸»è¦åº”ç”¨é¢†åŸŸçš„å‘å±•å†ç¨‹..."
)

# æ›´æ–°ä»»åŠ¡çŠ¶æ€  
await revise_roadmap(
    action="revise_subtask",
    subtask_idx=2,
    new_status="Done",
    update_to_subtask={...}
)
```

**å­ä»»åŠ¡4ï¼šæ•´åˆç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š**
```python
# åˆ›å»ºæŠ¥å‘Šæ•´åˆWorker
report_writer = await create_worker(
    worker_name="report_writer",
    worker_system_prompt="ä½ æ˜¯ä¸“ä¸šæŠ¥å‘Šå†™ä½œä¸“å®¶ï¼Œè´Ÿè´£æ•´åˆå¤šæ–¹ä¿¡æ¯ç”Ÿæˆé«˜è´¨é‡çš„ç»¼åˆæŠ¥å‘Š...",
    tool_names=["read_file", "write_file", "edit_file"],
    agent_description="ä¸“é—¨è´Ÿè´£æœ€ç»ˆæŠ¥å‘Šæ•´åˆå’Œæ’°å†™çš„ä¸“å®¶"
)

# æ‰§è¡ŒæŠ¥å‘Šæ•´åˆä»»åŠ¡
await execute_worker(
    subtask_idx=3,
    selected_worker_name="report_writer", 
    detailed_instruction="è¯»å–å‰é¢ä¸‰ä¸ªå­ä»»åŠ¡ç”Ÿæˆçš„æ‰€æœ‰æ–‡ä»¶ï¼Œåˆ†ææ•´åˆä¿¡æ¯ï¼Œç”Ÿæˆç»“æ„åŒ–çš„AIå‘å±•å†å²æŠ¥å‘Š..."
)

# æ›´æ–°ä»»åŠ¡çŠ¶æ€
await revise_roadmap(
    action="revise_subtask",
    subtask_idx=3,
    new_status="Done",
    update_to_subtask={...}
)
```

---

### **é˜¶æ®µ11ï¼šæœ€ç»ˆçŠ¶æ€å’Œç»“æœ**

#### **11.1 æœ€ç»ˆPlannerNoteBookçŠ¶æ€**
```python
# æ‰€æœ‰å­ä»»åŠ¡å®Œæˆåçš„çŠ¶æ€
final_planner_notebook = PlannerNoteBook(
    user_input=["è¯·ç ”ç©¶å¹¶ç¼–å†™AIå‘å±•å†å²æŠ¥å‘Š"],
    detail_analysis_for_plan="è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç ”ç©¶ä»»åŠ¡...",
    roadmap=RoadMap(
        original_task="ç”Ÿæˆä¸€ä»½å…³äºAIå‘å±•å†å²çš„ç»¼åˆç ”ç©¶æŠ¥å‘Š...",
        decomposed_tasks=[
            SubTaskStatus(status="Done", workers=[history_researcher], updates=[...], attempt=1),
            SubTaskStatus(status="Done", workers=[person_analyst], updates=[...], attempt=1), 
            SubTaskStatus(status="Done", workers=[app_analyst], updates=[...], attempt=1),
            SubTaskStatus(status="Done", workers=[report_writer], updates=[...], attempt=1)
        ]
    ),
    files={
        "ai_technology_timeline.md": "AIæŠ€æœ¯å‘å±•æ—¶é—´çº¿æ–‡æ¡£",
        "ai_pioneers.md": "AIé¢†åŸŸå…³é”®äººç‰©è´¡çŒ®æŠ¥å‘Š", 
        "ai_applications.md": "AIåº”ç”¨é¢†åŸŸå‘å±•åˆ†æ",
        "AI_Development_History_Report.md": "å®Œæ•´çš„AIå‘å±•å†å²ç»¼åˆæŠ¥å‘Š"
    },
    full_tool_list=[...]  # å®Œæ•´å·¥å…·åˆ—è¡¨
)
```

#### **11.2 æœ€ç»ˆç³»ç»Ÿå“åº”**
MetaPlannerä¼šæ ¹æ®æ‰€æœ‰å­ä»»åŠ¡çš„å®Œæˆæƒ…å†µï¼Œç”Ÿæˆæœ€ç»ˆçš„ç”¨æˆ·å“åº”ï¼š

```python
# MetaPlanneræœ€ç»ˆè¾“å‡ºç»™ç”¨æˆ·
final_response = Msg(
    role="assistant",
    name="Task-Meta-Planner", 
    content="""
æˆ‘å·²ç»æˆåŠŸå®Œæˆäº†AIå‘å±•å†å²ç ”ç©¶æŠ¥å‘Šçš„ç¼–å†™ä»»åŠ¡ã€‚é€šè¿‡MetaPlanneræ¨¡å¼ï¼Œæˆ‘å°†è¿™ä¸ªå¤æ‚ä»»åŠ¡åˆ†è§£ä¸º4ä¸ªå­ä»»åŠ¡ï¼Œå¹¶åˆ›å»ºäº†ä¸“é—¨çš„Worker Agentæ¥å®Œæˆæ¯ä¸ªéƒ¨åˆ†ï¼š

## å®Œæˆçš„å­ä»»åŠ¡ï¼š
1. âœ… **æŠ€æœ¯çªç ´å†å²æ”¶é›†** - Worker: history_researcher
   - ç”Ÿæˆäº†ai_technology_timeline.mdï¼ŒåŒ…å«1950-2024å¹´çš„50ä¸ªé‡è¦æŠ€æœ¯çªç ´
   
2. âœ… **å…³é”®äººç‰©åˆ†æ** - Worker: person_analyst  
   - ç”Ÿæˆäº†ai_pioneers.mdï¼Œåˆ†æäº†20ä½AIé¢†åŸŸé‡è¦ç ”ç©¶è€…çš„è´¡çŒ®
   
3. âœ… **åº”ç”¨é¢†åŸŸå‘å±•** - Worker: app_analyst
   - ç”Ÿæˆäº†ai_applications.mdï¼Œæ¶µç›–äº†åŒ»ç–—ã€é‡‘èã€æ•™è‚²ç­‰ä¸»è¦åº”ç”¨é¢†åŸŸ
   
4. âœ… **ç»¼åˆæŠ¥å‘Šæ•´åˆ** - Worker: report_writer
   - ç”Ÿæˆäº†AI_Development_History_Report.mdï¼ŒåŒ…å«å®Œæ•´çš„å‘å±•å†å²åˆ†æ

## æœ€ç»ˆæˆæœï¼š
ğŸ“„ **AI_Development_History_Report.md** - è¿™æ˜¯ä¸€ä»½ç»“æ„å®Œæ•´çš„ç»¼åˆæŠ¥å‘Šï¼ŒåŒ…å«ï¼š
- AIå‘å±•æ¦‚è¿°å’Œé‡è¦é‡Œç¨‹ç¢‘
- æŠ€æœ¯çªç ´æ—¶é—´çº¿å’Œå½±å“åˆ†æ  
- å…³é”®äººç‰©åŠå…¶è´¡çŒ®ä»‹ç»
- å„åº”ç”¨é¢†åŸŸå‘å±•ç°çŠ¶å’Œè¶‹åŠ¿
- æœªæ¥å‘å±•æ–¹å‘å±•æœ›

æ‰€æœ‰æ–‡ä»¶å·²ä¿å­˜åœ¨ä»»åŠ¡ç›®å½•ä¸­ï¼Œæ‚¨å¯ä»¥æŸ¥çœ‹è¯¦ç»†å†…å®¹ã€‚æ•´ä¸ªç ”ç©¶è¿‡ç¨‹é‡‡ç”¨äº†ç³»ç»ŸåŒ–çš„æ–¹æ³•ï¼Œç¡®ä¿äº†ä¿¡æ¯çš„å‡†ç¡®æ€§å’Œå®Œæ•´æ€§ã€‚
"""
)
```

---

## ğŸ”¥ å…³é”®è®¾è®¡äº®ç‚¹æ€»ç»“

### **1. çŠ¶æ€ç®¡ç†çš„ç²¾ç¡®æ€§**
```python
# æ¯ä¸ªå…³é”®æ­¥éª¤éƒ½æœ‰Hookè¿›è¡ŒçŠ¶æ€ç®¡ç†
self.register_instance_hook("pre_reasoning", "planner_compose_reasoning_msg_pre_reasoning_hook")
self.register_instance_hook("post_reasoning", "save_state_post_reasoning_hook")  
self.register_instance_hook("post_acting", "save_state_post_action_hook")
```

### **2. Workerçš„ç‹¬ç«‹æ€§å’Œåä½œæ€§**
```python
# æ¯ä¸ªWorkeræœ‰ç‹¬ç«‹çš„å†…å­˜å’Œå·¥å…·é›†
worker = ReActAgent(
    memory=InMemoryMemory(),  # ç‹¬ç«‹å†…å­˜
    toolkit=worker_toolkit,   # ä¸“ç”¨å·¥å…·é›†
)

# ä½†ç»“æœé€šè¿‡PlannerNoteBookç»Ÿä¸€èšåˆ
self.planner_notebook.files[filepath] = desc
self.planner_notebook.roadmap.decomposed_tasks[idx].workers.append(worker_info)
```

### **3. ç»“æ„åŒ–æ•°æ®æµ**
```python
# ä¸¥æ ¼çš„æ•°æ®ç»“æ„ç¡®ä¿ä¿¡æ¯å®Œæ•´æ€§
WorkerResponse(subtask_progress_summary, next_step, generated_files, task_done)
SubTaskStatus(subtask_specification, status, updates, attempt, workers)
PlannerNoteBook(time, user_input, detail_analysis_for_plan, roadmap, files, full_tool_list)
```

### **4. é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶**
```python
# æ–‡ä»¶å­˜åœ¨æ€§éªŒè¯
if await check_file_existence(filepath, self.worker_full_toolkit):
    self.planner_notebook.files[filepath] = desc
else:
    worker_response.generated_files.pop(filepath)

# çŠ¶æ€æŒä¹…åŒ–æ”¯æŒ
if self.state_saving_dir:
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(self.state_dict(), f, ensure_ascii=False, indent=4)
```

è¿™å¥—æœºåˆ¶ç¡®ä¿äº†å¤æ‚ä»»åŠ¡çš„å¯é æ‰§è¡Œï¼Œæ¯ä¸ªç¯èŠ‚éƒ½æœ‰è¯¦ç»†çš„çŠ¶æ€è¿½è¸ªå’Œé”™è¯¯å¤„ç†ï¼ŒçœŸæ­£å®ç°äº†"è§„åˆ’-æ‰§è¡Œ-ç›‘æ§-è°ƒæ•´"çš„å®Œæ•´é—­ç¯ã€‚

æƒ³äº†è§£æ›´å¤šæŠ€æœ¯ç»†èŠ‚ï¼Œå¯ä»¥æ·±å…¥ç ”ç©¶ [Agent ç³»ç»Ÿæ¶æ„](8-agent-system-architecture) å’Œ [æµæ°´çº¿ä¸å·¥ä½œæµç¼–æ’](10-pipeline-and-workflow-orchestration)ã€‚